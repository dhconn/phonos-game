<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phono</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400..700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            color: #333;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 100%;
            max-width: 600px;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-family: 'Dancing Script', cursive; /* Applied Dancing Script font */
            font-size: 2.8em;
        }

        #gameTagline {
            font-size: 1.2em; /* Slightly smaller than h1 */
            color: #555; /* Slightly muted color */
            margin-top: -10px; /* Pull it closer to the title */
            margin-bottom: 25px; /* Add some space below it */
            font-style: italic; /* Give it a tagline look */
        }

        .game-controls, .game-info {
            margin-bottom: 20px;
        }

	.mode-selection label {
            margin: 0 10px;
            font-size: 1.1em;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
	    transition: background-color 0.3s ease, box-shadow 0.2s ease;
            outline: none; /* remove default outline, will add custom */        }

	/* Focus styles for accessibility */
	button:focus {
	    outline: 3px solid #ffd700; /* bright yellow outline for strong focus */
	    outline-offset: 3px;
	    box-shadow: 0 0 5px 2px #ffd700;
	}

        button#startGameButton {
            background-color: #28a745;
            color: white;
        }

	button#startGameButton:hover:enabled {
	    background-color: #218838;
	}

        button#startGameButton:hover:enabled {
            background-color: #218838;
        }

        button#resetGameButton {
            background-color: #dc3545;
            color: white;
        }

	button#resetGameButton:hover:enabled {
	    background-color: #c82333;
	}
        
        button#submitButton {
            background-color: #007bff;
            color: white;
        }

        button#submitButton:hover:enabled {
            background-color: #0056b3;
        }

        button#showRulesButton {
            background-color: #6c757d;
            color: white;
        }

        button#showRulesButton:hover {
            background-color: #5a6268;
        }
       
	/* Styling for the accordion headers */
	.accordion-header {
	    background-color: #f2f2f2; /* Light gray background */
	    color: #333;
	    cursor: pointer;
	    padding: 15px;
	    width: 100%;
	    border: none;
	    text-align: left;
	    outline: none;
	    font-size: 1.1em;
	    transition: background-color 0.2s ease;
	    border-bottom: 1px solid #ddd; /* Separator line */
	    display: flex; /* For optional arrow/icon alignment */
	    justify-content: space-between; /* Pushes arrow to the right */
	    align-items: center;
	}

	.accordion-header:hover {
	    background-color: #e0e0e0; /* Darker on hover */
	}

	/* Optional: Add a visual indicator for open/closed state */
	.accordion-header::after {
	    content: '\02795'; /* Plus sign unicode */
	    font-size: 0.8em;
	    color: #777;
	    float: right;
	    margin-left: 5px;
	    transition: transform 0.2s ease;
	}

	.accordion-header.active::after {
	    content: "\2796"; /* Minus sign unicode */
	    transform: rotate(0deg); /* No rotation for plus/minus */
	}

	/* Styling for the accordion content */
	.accordion-content {
	    padding: 0 15px; /* Padding for the content inside */
	    background-color: #f9f9f9; /* Slightly different background for content */
	    max-height: 0; /* Initially hidden */
	    overflow: hidden; /* Hide overflow */
	    transition: max-height 0.3s ease-out, padding 0.3s ease-out; /* Smooth transition */
	    border-bottom: 1px solid #eee; /* Separator line for content */
	}

	/* Styling for the active (open) content */
	.accordion-header.active + .accordion-content {
	    max-height: 9999px; /* Adjust this value! Needs to be larger than max possible content height */
	    padding: 15px; /* Apply padding when active */
	}

	/* Optional: Remove bottom border for the last item for a cleaner look */
	.accordion-item:last-child .accordion-header,
	.accordion-item:last-child .accordion-content {
	    border-bottom: none;
	}

	/* Rules Section as a Modal Overlay */
        #rulesSection {
            display: none; /* Hidden by default */
            position: fixed; /* Stays in the same position even if the page scrolls */
            z-index: 1001; /* High z-index to be on top of other content */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto; /* Enable scroll if content is too long */
            background-color: rgba(0, 0, 0, 0.8); /* Black w/ opacity - dark overlay */
            align-items: center; /* Center vertically */
            justify-content: center; /* Center horizontally */
        }

	/* NEW CSS RULE: This class will make the rules section visible and use flexbox */
	#rulesSection.active-modal {
	    display: flex;
	}

        .rules-content {
            background-color: #E0F2F7; /* White background for the content box */
            margin: auto; /* Centers the box */
            padding: 30px;
            border: 1px solid #888;
            border-radius: 10px;
            width: 90%; /* Adjust as needed */
            max-width: 700px; /* Max width for readability */
            max-height: 90vh; /* Max height for scrollability */
            overflow-y: auto; /* Allows scrolling within the rules box if content is long */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            position: relative; /* For positioning the close button inside */
            text-align: left; /* Align text within the content box */
        }

        .rules-content h2 {
            text-align: center;
            color: #2a6f9a; /* Or your preferred heading color */
            margin-bottom: 20px;
        }

        .rules-content ul {
            list-style-type: disc;
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .rules-content li {
            margin-bottom: 8px;
        }

        .close-rules-button {
            color: #aaa;
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .close-rules-button:hover,
        .close-rules-button:focus {
            color: #333;
            text-decoration: none;
        }

        /* Optional: Hide main game elements when rules are shown if you prefer "instead of" */
        /* You might need to add a class to your main container for this,
           and toggle that class in JS. For now, we'll just overlay. */
	/* Disabled buttons - slightly muted look */
	button:disabled {
	    opacity: 0.6;
	    cursor: not-allowed;
	    box-shadow: none;
	}

        /* Styles for Share Buttons */
        #shareOptions button {
            background-color: #007bff; /* A default blue */
            color: white;
            margin: 5px;
        }
        #shareOptions button#facebookShareButton { 
            background-color: #1877F2; /* Facebook blue */
        }
        #shareOptions button#facebookShareButton:hover {
            background-color: #166FE5;
        }
        #shareOptions button#copyShareButton {
            background-color: #6c757d; /* Muted color for copy */
        }
        #shareOptions button#copyShareButton:hover {
            background-color: #5a6268;
        }
        #shareOptions button#challengeFriendButton { 
            background-color: #ff9800; /* Orange */
        }
        #shareOptions button#challengeFriendButton:hover {
            background-color: #e68900;
        }

        /* New style for the hint button */
        #hintSection button#hintButton {
            background-color: #ffc107; /* Yellowish/orange */
            color: #333;
            margin-top: 15px; 
            margin-bottom: 5px;
        }

        #hintSection button#hintButton:hover:enabled {
            background-color: #e0a800;
        }

        #hintSection {
            margin-top: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        input[type="text"] {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1.1em;
            width: calc(100% - 130px); /* Adjust width to fit button */
            margin-right: 10px;
            box-sizing: border-box;
        }

        #wordDisplay h2 {
            font-size: 2.5em;
            color: #007bff;
            margin: 20px 0;
            min-height: 1.5em; /* Ensure consistent height */
        }

        .game-info p {
            font-size: 1.2em;
            margin: 5px 0;
        }

        .game-info span {
            font-weight: bold;
            color: #3498db;
        }

        .message {
            margin-top: 20px;
            font-size: 1.1em;
            color: #e74c3c; /* Red for errors/info */
            min-height: 1.2em; /* Ensure consistent height */
        }
        /* Ensure messages have consistent styling, hintDisplay might be separate from messageDisplay */
        #hintDisplay {
            margin-top: 10px;
            font-size: 1.1em;
            min-height: 1.2em;
            color: #007bff; /* Hint text will be blue */
        }

        /* Styles for the new sections */
        #wordsUsedSection, #topScoresSection, #rulesSection, #shareOptions {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
            margin-top: 20px;
            text-align: left;
        }
        
        #rulesSection {
            background-color: #e9f5ff; /* Light blue background */
            border: 1px solid #cceeff; /* Blue border */
        }
        /* Specific styling for share options section */
        #shareOptions {
            background-color: #e0ffe0; /* Light green background */
            border: 1px solid #ccffcc; /* Green border */
            text-align: center;
        }


        #wordsUsedSection h4, #topScoresSection h4, #rulesSection h4, #shareOptions h4 {
            color: #444;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        #wordsUsedList, #topScoresList {
            list-style-type: none; /* Remove default bullet/number */
            padding: 0;
            margin: 0;
            font-size: 0.95em;
            color: #555;
            max-height: 120px; /* Limit height for scrolling */
            overflow-y: auto; /* Enable scrolling */
            border-top: 1px dashed #eee;
            padding-top: 10px;
        }

        #wordsUsedList li, #topScoresList li {
            padding: 4px 0;
            border-bottom: 1px dotted #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #topScoresList {
            list-style-type: decimal; /* Use decimal for numbered list */
            padding-left: 20px; /* Indent for numbers */
            text-align: left; /* Align list items left */
            margin: 0 auto; /* Center the ol itself */
            display: inline-block; /* Allow centering of the ol */
        }

        #topScoresList li:last-child {
            border-bottom: none;
        }

        #rulesSection ol, #rulesSection ul {
            padding-left: 20px;
            margin-bottom: 10px;
        }
        #rulesSection li {
            margin-bottom: 5px;
            line-height: 1.4;
        }

	/* Styles specifically for screens with a maximum width of, say, 600px (typical for phones/small tablets) */
	@media screen and (max-width: 600px) {
	  body {
            font-size: 14px; /* Make text slightly smaller for mobile */
            padding: 10px; /* Reduce overall padding */
    	}

	    .container {
                padding: 15px; /* Override for smaller screens */
                border-radius: 5px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            }

            h1 {
                font-size: 1.8em;
            }

            input[type="text"],
            button {
                width: calc(100% - 10px); /* Make nearly full width (minus margins) */
                margin: 5px 0; /* Stack vertically */
                padding: 15px; /* Larger touch target */
                font-size: 18px; /* Larger text */
            }

            .game-controls {
                flex-direction: column; /* Stack if they were side-by-side */
                align-items: stretch;
            }

            .button-group button {
                margin: 5px 0; /* Stack buttons in a group */
            }
    }
    </style>
</head>
<body>
    <div class="container">
        <h1>Phono</h1> <p id="gameTagline">Outthink. Outlink. Outlast.</p>
	<div class="stats-item">Level: <span id="levelDisplay">1</span></div>
        <div class="game-controls">

	    <button id="startGameButton" disabled aria-label="Start New Game">Start New Game</button>
            <button id="resetGameButton" style="display: none;" disabled aria-label="Reset the game">Reset Game</button>
            <button id="showRulesButton" aria-label="Show the game rules">Show Rules</button>
	    <button id="pauseButton" aria-label="Pause or Resume Game">Pause Game</button>
            <div id="pausesDisplay">Pauses Left: 2</div>
        </div>

        <div class="game-info">
            <p>Score: <span id="scoreDisplay">0</span></p>
            <p>Streak: <span id="streakDisplay">0</span></p>
            <p>Time Left: <span id="timerDisplay">--</span></p>
            <p>High Score: <span id="highScoreDisplay">0</span></p>
            <p>Highest Streak (Session): <span id="highestSessionStreakDisplay">0</span></p>
        </div>

        <div id="wordDisplay">
            <h2 id="currentWordDisplay"></h2>
        </div>

        <div id="inputSection">
            <input type="text" id="wordInput" placeholder="Enter word here" disabled>
            <button id="submitButton" aria-label="Submit your answer" disabled>Submit Word</button>
        </div>

        <div id="hintSection">
            <button id="hintButton" disabled>Get Hint (Cost: 100 pts)</button>
            <p id="hintDisplay" class="message"></p>
        </div>

        <p id="messageDisplay" class="message"></p>

        <div id="shareOptions" style="display: none;">
            <h4>Share Your Achievement!</h4>
            <button id="copyShareButton">Copy Score Message</button>
            <button id="facebookShareButton">Share on Facebook</button>
            <button id="challengeFriendButton">Challenge a Friend</button>
        </div>

        <div id="wordsUsedSection">
            <h4>Words Used This Round:</h4>
            <ul id="wordsUsedList">
                </ul>
        </div>

        <div id="topScoresSection">
            <h4>Top Scores:</h4>
            <ol id="topScoresList">
                <li>N/A</li> </ol>
        </div>

    </div>

    <div id="rulesSection">
      <div class="rules-content">
        <span class="close-rules-button">&times;</span>
	   <div class="accordion-item">
	      <button class="accordion-header">How to Play Phono</button>
	      <div class="accordion-content">
               <ol>
		<li>The game starts with a word.</li>
		<li>Your goal is to type a new word that **shares a common sound chunk** with the previous word.</li>
                <li>**Sound Chunk Rule:** The shared sound chunk must contain at least one vowel phoneme. That means a sound with a vowel and consonant, such as the "AP" sound in "NAPKIN." A consonant alone won't cut it: For example, "BIKER" won't work as the next word after "CATNAP," even though they share the "K" (or hard C) sound.</li> 
		<li>**Syllable Rule:** Your new word must have **at least 2 syllables**.</li>
                <li>**No Repeats:** You cannot use the same word twice in one game.</li>
                <li>You have limited time per turn!</li>
               </ol>
	</div>
     </div>

	<div class="accordion-item">
        <button class="accordion-header">Climbing Through the Levels</button>
        <div class="accordion-content">
            <ul>
		<li>It takes 10 successful plays to complete Level 1.</li>
		<li>Each level takes 10 more plays, but you lose 5 seconds per word.</li>
		<li>Try to get through all five levels - if you can.</li>
		<li>After that you can play "forever mode" as long as you're able.</li>
	    </ul>
	</div>
     </div>

	    <div class="accordion-item">
		<button class="accordion-header">Scoring</button>
	        <div class="accordion-content">
            <ul>
                <li>Base points for each correct word.</li>
                <li>**Time Bonus:** Earn extra points for submitting words quickly.</li>
                <li>**Syllable Bonus:** Get bonus points for longer words (more syllables).</li>
                <li>**Sound Chunk bonus:** Get more points for words that share more sound chunks!</li>
                <li>**Hints:** Cost 100 points each.</li>
            </ul>
	</div>
     </div>

	    <div class="accordion-item">
        	<button class="accordion-header">Game Over</button>
	        <div class="accordion-content">            
	    <ul>
                <li>If you run out of time - although you can purchase a "Pause" for 100 points. </li>
                <li>If your word does not share a valid sound with the previous word.</li>
                <li>If your word has fewer than 2 syllables.</li>
            </ul>
            <p>Good luck and have a Phantastic Phono!</p>
        </div>
    </div>

    <script>
        // === PRONOUNCING.JS MODULE (EMBEDDED) ===
        // This IIFE contains the dictionary logic for pronunciation and rhymes.
        window.pronouncing = (function () {
            var dict = {};
            var phones = {};
            var dictionaryLoaded = false; // Flag to track if dictionary is loaded

            var mod = {
                setDictionary: function (text) {
                    text.split('\n').forEach(function (line) {
                        if (!line) return;
                        var parts = line.split(/\s+/);
                        var word = parts[0].toLowerCase();
                        // IMPORTANT FIX: Clean words with (n) suffixes to map to base word
                        word = word.replace(/\(\d+\)$/, ''); // Remove (1), (2) etc. from word suffixes
                        var phone = parts.slice(1);

                        // Ensure dict[word] is an array before pushing
                        if (!Array.isArray(dict[word])) {
                            dict[word] = [];
                        }
                        dict[word].push(phone);

                        phone.forEach(function (p) {
                            if (!phones[p]) {
                                phones[p] = [];
                            }
                            phones[p].push(word);
                        });
                    });
                    console.log("Pronouncing.js dictionary initialized with " + Object.keys(dict).length + " words.");
                    dictionaryLoaded = true; // Set flag after dictionary is loaded
                },

                // Returns all pronunciations (arrays of phonemes) for a given word
                phonesForWord: function (word) {
                    return dict[word.toLowerCase()];
                },

                // Returns a list of words that rhyme with the given word
                // (Note: This function is not used in the final custom rule, but kept for completeness
                // as it's part of the pronouncing.js library)
                rhymes: function (word) {
                    var phones = this.phonesForWord(word);
                    if (!phones) return [];
                    var primaryPhone = phones[0]; // Take the first pronunciation
                    var vowelIndex = -1;
                    for (var i = primaryPhone.length - 1; i >= 0; i--) {
                        if (primaryPhone[i].match(/[AEIOU]/)) { // Simple check for vowel phoneme
                            vowelIndex = i;
                            break;
                        }
                    }
                    if (vowelIndex === -1) return []; // No vowel found, no rhyme

                    var rhymeSound = primaryPhone.slice(vowelIndex).join(' ');
                    var matchingWords = [];
                    for (var p in phones) {
                        if (p.includes(rhymeSound)) {
                            phones[p].forEach(function (w) {
                                if (w !== word) { // Don't include the word itself
                                    matchingWords.push(w);
                                }
                            });
                        }
                    }
                    return matchingWords;
                },

                // New getter to check if the dictionary is loaded
                isDictionaryLoaded: function() {
                    return dictionaryLoaded;
                },

                // New getter to access the dictionary (useful for picking random words)
                getDictionary: function() {
                    return dict;
                }
            };
            return mod;
        })();

        // === GLOBAL GAME STATE VARIABLES ===
        let currentScore = 0;
        let currentStreak = 0;
        let topScores = []; // Array to hold multiple top scores, saved to localStorage
        let highestSessionStreak = 0; // To track highest streak in the current browser session
        let usedWords = []; // To store words already used in the current round
        let maxTimePerTurn = 30; // Basic mode default
        let timeLeft = maxTimePerTurn;
        let timerInterval = null; // To hold the setInterval ID
        let gameActive = false; // To track if a game is currently running
        let currentWord = ''; // The word currently displayed for the player to respond to
	let gamePaused = false;
	let pausesAvailable = 2; // For example, 2 pauses per game/level
        let awaitingNextLevel = false; // Flag to control starting next level manually

	const PAUSE_COST_PER_USE = 100; // For example, 25 points per pause

        // === DOM ELEMENTS ===
        const scoreDisplay = document.getElementById('scoreDisplay');
        const streakDisplay = document.getElementById('streakDisplay');
        const timerDisplay = document.getElementById('timerDisplay');
        const highScoreDisplay = document.getElementById('highScoreDisplay'); // Will show the #1 score from topScores
        const highestSessionStreakDisplay = document.getElementById('highestSessionStreakDisplay');
        const wordsUsedList = document.getElementById('wordsUsedList');     // For used words this round
        const topScoresList = document.getElementById('topScoresList');    // For the persistent top scores list
        const startGameButton = document.getElementById('startGameButton');
        const resetGameButton = document.getElementById('resetGameButton');
        const currentWordDisplay = document.getElementById('currentWordDisplay');
        const wordInput = document.getElementById('wordInput');
        const submitButton = document.getElementById('submitButton');
        const messageDisplay = document.getElementById('messageDisplay');
        const showRulesButton = document.getElementById('showRulesButton');
        const rulesSection = document.getElementById('rulesSection');
        const shareOptions = document.getElementById('shareOptions');
        const copyShareButton = document.getElementById('copyShareButton');
        const facebookShareButton = document.getElementById('facebookShareButton');
        const challengeFriendButton = document.getElementById('challengeFriendButton');
        const hintButton = document.getElementById('hintButton'); 
        const hintDisplay = document.getElementById('hintDisplay'); 
	const pauseButton = document.getElementById('pauseButton');
	const pausesDisplay = document.getElementById('pausesDisplay');
	const levelDisplay = document.getElementById('levelDisplay');
	const levelCompleteSound = document.getElementById('levelCompleteSound');
	const closeRulesButton = document.querySelector('.close-rules-button'); // Ensure this is added globally

	// --- NEW LEVEL-RELATED VARIABLES ---
	let currentLevel = 1; // Start at Level 1
	const LEVEL_TARGET_WORDS = 10; // Number of words needed to complete each level
	// Map each level to its time limit (in seconds)
	const LEVEL_TIMES = {
	    1: 30, // Level 1: 30 seconds
	    2: 25, // Level 2: 25 seconds
	    3: 20, // Level 3: 20 seconds
	    4: 15, // Level 4: 15 seconds
	    5: 10  // Level 5: 10 seconds
	};
	let inForeverMode = false; // Flag to indicate if player is past Level 5
	// --- END NEW LEVEL-RELATED VARIABLES ---

        // === HELPER FUNCTIONS ===

        // Cleans phoneme stress markers (e.g., "AH0" -> "AH", "OW1" -> "OW")
        function cleanPhoneme(phoneme) {
            return phoneme.replace(/[012]/g, '');
        }

        // Determines if a cleaned phoneme (without stress marker) is a vowel sound.
        // Based on CMU Pronouncing Dictionary phoneme set.
        function isVowelPhoneme(phoneme) {
            const cleaned = cleanPhoneme(phoneme);
            // List of CMU vowel phonemes (without stress markers)
            const vowels = new Set(['AA', 'AE', 'AH', 'AO', 'AW', 'AY', 'EH', 'ER', 'EY', 'IH', 'IY', 'OW', 'OY', 'UH', 'UW']);
            return vowels.has(cleaned);
        }

        // Define a mapping for "similar" vowel phonemes for comparison purposes
        // This helps the game recognize intuitive sound connections that CMUdict might differentiate.
        const PHONEME_EQUIVALENCE_GROUP = {
            'AE': 'GROUP_A_LIKE', // as in 'cat'
            'AH': 'GROUP_A_LIKE', // as in 'cup', 'but'
            'AA': 'GROUP_A_LIKE', // as in 'father', 'hot'
            // 'AO': 'GROUP_O_LIKE', // 'all', 'caught' - can be grouped if needed, or kept distinct
            // 'OW': 'GROUP_O_LIKE', // 'go', 'boat'

            // Add other common "fudged" pairs if necessary in future
            // 'EH': 'GROUP_E_LIKE', // 'bed'
            // 'IH': 'GROUP_E_LIKE', // 'bid'
        };

        // Function to get a "normalized" phoneme for comparison, using the equivalence groups
        function getNormalizedPhoneme(phoneme) {
            const cleaned = cleanPhoneme(phoneme);
            return PHONEME_EQUIVALENCE_GROUP[cleaned] || cleaned; // Return grouped value if exists, else cleaned original
        }

        // Basic syllable counting function (can be simple, may not be 100% accurate for all words)
        function syllable(word) {
            const phones = pronouncing.phonesForWord(word);
            if (!phones || phones.length === 0) {
                console.warn(`No phonemes found for syllable count for: ${word}. Returning 0.`);
                return 0;
            }
            let count = 0;
            for (let i = 0; i < phones[0].length; i++) {
                if (isVowelPhoneme(phones[0][i])) {
                    count++;
                }
            }
            return Math.max(1, count);
        }

        // Helper function to get a random element from an array
        function getRandomElement(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }
	// Function to select a random word from the dictionary with at least 2 syllables
        function selectRandomGameWord() {
            const dictionaryWords = Object.keys(pronouncing.getDictionary());
            if (dictionaryWords.length === 0) {
                console.error("Error: Dictionary is empty, cannot select a random word.");
                return null;
            }

            let foundWord = null;
            let attempts = 0;
            const maxAttempts = 500; // Increased attempts for robust word selection

            while (!foundWord && attempts < maxAttempts) {
                const potentialWord = dictionaryWords[Math.floor(Math.random() * dictionaryWords.length)];
                try {
                    if (syllable(potentialWord) >= 2) {
                        foundWord = potentialWord;
                    }
                } catch (e) {
                    console.error("Error checking syllables for potential random word:", potentialWord, e);
                }
                attempts++;
            }

            if (!foundWord) {
                console.warn("Could not find a suitable random word (at least 2 syllables) after max attempts.");
            }
            return foundWord;
        }

        // === DICTIONARY LOADING ===
        async function loadPronouncingDictionary() {
            const dictPath = 'cmudict.dict';
            const remoteFallbackURL = 'https://raw.githubusercontent.com/cmusphinx/cmudict/master/cmudict.dict'; 

            let dictionaryText = '';
            messageDisplay.textContent = "Loading dictionary...";

            try {
                console.log("Attempting to load dictionary from relative path:", dictPath);
                const response = await fetch(dictPath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} from ${dictPath}`);
                }
                dictionaryText = await response.text();
                console.log("Loaded dictionary text from relative path.");
            } catch (error) {
                console.warn("Failed to load dictionary from relative path. Falling back to remote URL:", error);
                messageDisplay.textContent = "Failed to load local dictionary, trying remote...";

                try {
                    const response = await fetch(remoteFallbackURL);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} from ${remoteFallbackURL}`);
                    }
                    dictionaryText = await response.text();
                    console.log("Fetched dictionary text from remote URL.");
                } catch (remoteError) {
                    console.error("Failed to load dictionary from any source:", remoteError);
                    messageDisplay.textContent = `Failed to load dictionary: ${remoteError.message}`;
                    throw remoteError;
                }
            }

            if (dictionaryText) {
                pronouncing.setDictionary(dictionaryText);
            } else {
                throw new Error("Dictionary text is empty after loading attempts.");
            }
        }

        // === INITIALIZATION FUNCTION ===
        async function initGame() {
            messageDisplay.textContent = "Loading dictionary...";
            try {
                await loadPronouncingDictionary();
                messageDisplay.textContent = "Dictionary loaded. Ready to play!";
                startGameButton.disabled = false;
                // Only enable 'basic' mode by default, 'advanced' will be unlocked

                const storedTopScores = localStorage.getItem('phonoTopScores'); // Changed key to phonoTopScores
                if (storedTopScores) {
                    topScores = JSON.parse(storedTopScores);
                } else {
                    topScores = [];
                }
                
                updateDisplay();
                updateTopScoresDisplay();
                updatePausesDisplay(); // Call here to show initial pauses

                const urlParams = new URLSearchParams(window.location.search);
                const challengeWord = urlParams.get('challengeWord');
                if (challengeWord && pronouncing.phonesForWord(challengeWord) && syllable(challengeWord) >= 2) {
                    window.history.replaceState({}, document.title, window.location.pathname);
                    startGame(challengeWord);
                    messageDisplay.textContent = `You've been challenged! Continue the chain from "${challengeWord.toUpperCase()}"!`;
                }
		const levelCompleteSound = document.getElementById('levelCompleteSound');

		const rulesSection = document.getElementById('rulesSection');

            } catch (error) {
                console.error("Game Initialization Error:", error);
                messageDisplay.textContent = `Failed to initialize game: ${error.message}`;
            }
        }


        // === GAME CONTROL FUNCTIONS ===

        function updateDisplay() {
            scoreDisplay.textContent = currentScore;
            streakDisplay.textContent = currentStreak;
            timerDisplay.textContent = timeLeft;
            highScoreDisplay.textContent = topScores.length > 0 ? topScores[0] : 0; 
            highestSessionStreakDisplay.textContent = highestSessionStreak;
	    currentWordDisplay.textContent = currentWord.toUpperCase(); 
	    levelDisplay.textContent = inForeverMode ? "Forever" : currentLevel; // Show "Forever" or level number
        }

        function updateWordsUsedDisplay() {
            wordsUsedList.innerHTML = '';
            if (usedWords.length === 0) {
                return;
            }
            usedWords.forEach(word => {
                const li = document.createElement('li');
                li.textContent = word.toUpperCase();
                wordsUsedList.appendChild(li);
            });
            wordsUsedList.scrollTop = wordsUsedList.scrollHeight;
        }

        function updateTopScoresDisplay() {
            topScoresList.innerHTML = '';
            if (topScores.length === 0) {
                topScoresList.innerHTML = '<li>N/A</li>';
                highScoreDisplay.textContent = 0;
                return;
            }

            highScoreDisplay.textContent = topScores[0]; 

            topScores.forEach((score, index) => {
                const li = document.createElement('li');
                li.textContent = `${score} points`;
                topScoresList.appendChild(li);
            });
        }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);

            timeLeft = maxTimePerTurn;
            updateDisplay();

            timerInterval = setInterval(() => {
                timeLeft--;
                updateDisplay();

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                    endGame("Time's up! Game over. Your streak ended.");
                }
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

	function togglePause() {
    if (!gameActive) { // Cannot pause if game isn't even active
        messageDisplay.textContent = "Game not started. Click 'Start Game' to begin!";
        return;
    }

    if (!gamePaused) { // If game is currently running, pause it
        if (pausesAvailable <= 0) {
            messageDisplay.textContent = "No pauses left!";
            return;
        }

        // Deduct points
        currentScore = Math.max(0, currentScore - PAUSE_COST_PER_USE); // Ensure score doesn't go below 0
        pausesAvailable--; // Decrease available pauses

        // Update state
        gamePaused = true;
        clearInterval(timerInterval); // Stop the timer

        // Update UI
        wordInput.disabled = true; // Disable input while paused
        submitButton.disabled = true; // Disable submit button
        pauseButton.textContent = "Resume Game";
        messageDisplay.textContent = `Game Paused! -${PAUSE_COST_PER_USE} points. Click to resume.`;
        updateDisplay(); // Update score and other displays

    } else { // If game is currently paused, resume it
        // Update state
        gamePaused = false;
        startTimer(); // Resume the timer from where it left off

        // Update UI
        wordInput.disabled = false; // Enable input
        submitButton.disabled = false; // Enable submit button
        pauseButton.textContent = "Pause Game";
        messageDisplay.textContent = ""; // Clear pause message (or revert to previous if desired)
    }
    updatePausesDisplay(); // Update the display for pauses left
}

	function updatePausesDisplay() {
	if (pausesDisplay) { // Check if the display element exists
        pausesDisplay.textContent = `Pauses Left: ${pausesAvailable}`;
    }
}
        function endGame(message) {
            gameActive = false;
            stopTimer();
            wordInput.disabled = true;
            submitButton.disabled = true;
            hintButton.disabled = true; 
            hintDisplay.textContent = ""; 
            pauseButton.disabled = true; // Disable pause button at game end
            resetGameButton.disabled = true; // Ensure disabled at game end
            currentWordDisplay.textContent = "GAME OVER!";
            
            if (currentStreak > highestSessionStreak) {
                highestSessionStreak = currentStreak;
            }

            if (currentScore > 0) {
                topScores.push(currentScore);
                topScores.sort((a, b) => b - a);
                topScores = topScores.slice(0, 5);
                localStorage.setItem('phonoTopScores', JSON.stringify(topScores)); 
            }

            scoreDisplay.textContent = currentScore;
            streakDisplay.textContent = currentStreak;
            messageDisplay.textContent = message;
            if (currentScore > 0 && topScores.length > 0 && currentScore === topScores[0]) {
                 messageDisplay.textContent += ` NEW OVERALL HIGH SCORE: ${topScores[0]}!`;
            }

            updateDisplay();
            updateTopScoresDisplay();

            startGameButton.style.display = 'inline-block';
            resetGameButton.style.display = 'none'; 

            shareOptions.style.display = 'block';
        }

        function resetGame() {
            stopTimer();
            currentScore = 0;
            currentStreak = 0;
            timeLeft = maxTimePerTurn;
            gameActive = false;
            usedWords = [];
            currentLevel = 1; // Reset level
            inForeverMode = false; // Reset forever mode
            pausesAvailable = 2; // Reset pauses for a new game
            gamePaused = false; // Ensure game is not paused
            awaitingNextLevel = false; // Reset the flag

            updateWordsUsedDisplay();
            updateDisplay();
            updateTopScoresDisplay();
            updatePausesDisplay(); // Update pause display on reset

            messageDisplay.textContent = "Click 'Start New Game' to begin!";
            currentWordDisplay.textContent = "";
            wordInput.value = '';
            wordInput.disabled = true;
            submitButton.disabled = true;
            hintButton.disabled = true;
            hintDisplay.textContent = "";
            pauseButton.disabled = true; // Disable pause button on reset
            pauseButton.textContent = "Pause Game"; // Reset pause button text
            resetGameButton.disabled = true; // Ensure disabled after reset

            startGameButton.style.display = 'inline-block';
            resetGameButton.style.display = 'none';

            shareOptions.style.display = 'none';
        }

	function displayLevelCompleteScreen(levelCompleted, inForeverMode = false) {
            gameActive = false; // Pause game logic
            stopTimer(); // Stop the timer
	// Play level complete sound if the element is found
    	if (levelCompleteSound) {
        levelCompleteSound.play().catch(error => {
            console.error("Error playing level complete sound:", error);
        });
    } else {
        console.warn("Level complete sound element not found when trying to play it!");
    }

            let message = "";
            if (inForeverMode) {
                message = `ðŸŽ‰ CONGRATULATIONS! You've conquered all levels! ðŸŽ‰\nNow entering FOREVER MODE! See how far you can go!`;
            } else {
                message = `ðŸŽ‰ LEVEL ${levelCompleted} COMPLETE! ðŸŽ‰\nGet ready for Level ${levelCompleted + 1}!`;
            }

            messageDisplay.textContent = message;
            awaitingNextLevel = true; // Set flag to indicate we're waiting for player to continue

            startGameButton.textContent = "Continue to Next Level"; // Change button text
            startGameButton.style.display = 'inline-block'; // Make button visible
            startGameButton.disabled = false; // Ensure button is clickable

            // Disable game inputs while on the level complete screen
            wordInput.disabled = true;
            submitButton.disabled = true;
            hintButton.disabled = true;
            pauseButton.disabled = true; // Also disable pause button
            wordInput.disabled = true;
            submitButton.disabled = true;
            hintButton.disabled = true;
            pauseButton.disabled = true; // Disable pause button during transition

            // You might want to add a "Continue" button here that calls startNextLevel()
            // For now, let's just automatically transition after a short delay

        }

	function startNextLevel() {
	    currentLevel++;
            currentStreak = 0; // Reset streak for the new level
	    // Do NOT clear usedWords here. All previous words remain unusable.


            const newRandomWord = selectRandomGameWord(); // <--- Get a brand new random word
            if (!newRandomWord) {
                messageDisplay.textContent = "Error: Could not find a suitable word for the next level.";
                endGame("Failed to find next level word.");
                return;
            }
            currentWord = newRandomWord; // <--- Set the new word as the current word

            usedWords.push(currentWord); // <--- Add the new starting word to used words for this level
            updateWordsUsedDisplay();
            pausesAvailable = 2; // Reset pauses for the new level (optional, depends on your game design)
            updatePausesDisplay();

            if (currentLevel > 5) { // Assuming 5 is the max level before forever mode
                inForeverMode = true;
                maxTimePerTurn = 10; // Forever mode could have a fixed, challenging time
                localStorage.setItem('phonoAdvancedUnlocked', 'true'); // Unlock advanced mode permanently
                displayLevelCompleteScreen(5, true); // Call with inForeverMode = true
                return; // Exit as displayLevelCompleteScreen will handle next steps
            } else {
                maxTimePerTurn = LEVEL_TIMES[currentLevel];
            }

            gameActive = true;
            wordInput.disabled = false;
            submitButton.disabled = false;
            hintButton.disabled = false;
            pauseButton.disabled = false;
            messageDisplay.textContent = `Level ${currentLevel} started! Time per word: ${maxTimePerTurn}s.`;
            wordInput.focus();
            startTimer();
            updateDisplay();
        }

        function startNextTurn() {
            gameActive = true;
            wordInput.disabled = false;
            submitButton.disabled = false;
            hintButton.disabled = false;
            pauseButton.disabled = false;
            messageDisplay.textContent = `Keep going in Forever Mode!`;
            wordInput.focus();
            startTimer();
            updateDisplay();
        }

	function startGame(startWord = null) {
            if (!pronouncing.isDictionaryLoaded()) {
                 messageDisplay.textContent = "Dictionary not loaded yet. Please wait.";
                 return;
            }

            resetGame(); // Reset any existing game state
            gameActive = true;

            // Disable all mode radios once game starts
            startGameButton.style.display = 'none';
            resetGameButton.style.display = 'inline-block';
            resetGameButton.disabled = false; // Enable the Reset Game button

            wordInput.disabled = false;
            submitButton.disabled = false;
            hintButton.disabled = false;
            hintDisplay.textContent = "";
            pauseButton.disabled = false; // Enable pause button at game start
            updatePausesDisplay(); // Show initial pauses
            wordInput.focus();

            if (startWord && pronouncing.phonesForWord(startWord) && syllable(startWord) >= 2) {
                currentWord = startWord;
} else {
                const newRandomWord = selectRandomGameWord();
                if (!newRandomWord) {
                    messageDisplay.textContent = "Error: Could not find a suitable random starting word.";
                    endGame("Failed to find starting word.");
                    return;
                }
                currentWord = newRandomWord;
            }
            usedWords.push(currentWord);
            updateWordsUsedDisplay();
            currentWordDisplay.textContent = currentWord.toUpperCase();
            messageDisplay.textContent = "";
            startTimer();
        }

        // === MAIN GAME LOGIC (transferSound) ===
        // isHintCheck: Set to true if this call is for a hint, to suppress console logs
        function transferSound(prevWord, newWord, isHintCheck = false) { 
            if (!isHintCheck) { // Only log if it's not a hint check
                console.log(`--- Custom Phono Rule: prevWord=${prevWord}, newWord=${newWord} ---`);
            }

            const prevPhonesArr = pronouncing.phonesForWord(prevWord);
            const newPhonesArr = pronouncing.phonesForWord(newWord);

            if (!prevPhonesArr || prevPhonesArr.length === 0) {
                if (!isHintCheck) console.warn(`No phonemes found for previous word: ${prevWord}`);
                return null;
            }
            if (!newPhonesArr || newPhonesArr.length === 0) {
                if (!isHintCheck) console.warn(`No phonemes found for new word: ${newWord}`);
                return null;
            }

            const prevPhones = prevPhonesArr[0].map(cleanPhoneme);
            const newPhones = newPhonesArr[0].map(cleanPhoneme);

            if (!isHintCheck) {
                console.log(`Cleaned Prev Phones (${prevWord}):`, prevPhones);
                console.log(`Cleaned New Phones (${newWord}):`, newPhones);
            }

            let newWordSyllables;
            try {
                newWordSyllables = syllable(newWord);
                if (!isHintCheck) console.log(`Syllables for new word "${newWord}": ${newWordSyllables}`);
                if (newWordSyllables < 2) {
                    if (!isHintCheck) {
                        console.log(`Rule 3 failed: "${newWord}" has ${newWordSyllables} syllables, requires 2 or more.`);
                        messageDisplay.textContent = `"${newWord}" must have at least 2 syllables.`;
                    }
                    return null;
                }
            } catch (e) {
                if (!isHintCheck) {
                    console.error("Error calculating syllables for new word:", e);
                    messageDisplay.textContent = `Error checking syllables for "${newWord}".`;
                }
                return null;
            }

            let commonChunkFound = false;
            let foundChunkText = '';

            // Iterate through all possible chunks from prevPhones
            for (let i = 0; i < prevPhones.length; i++) {
                for (let j = i; j < prevPhones.length; j++) {
                    const currentChunk = prevPhones.slice(i, j + 1);

                    if (currentChunk.length === 0) continue;

                    // Ensure the current chunk (from prevWord) contains at least one vowel
                    const containsVowel = currentChunk.some(p => isVowelPhoneme(p));
                    if (!containsVowel) {
                        continue;
                    }

                    // --- NEW LOGIC FOR FLEXIBLE MATCH ---
                    // Try to find this currentChunk (flexibly) within newPhones
                    
                    // Iterate through newPhones to find a sequence that flexibly matches currentChunk
                    for (let k = 0; k <= newPhones.length - currentChunk.length; k++) {
                        let match = true;
                        // Compare the normalized versions of phonemes
                        for (let l = 0; l < currentChunk.length; l++) {
                            // If normalized phonemes don't match, this chunk is not a flexible match
                            if (getNormalizedPhoneme(currentChunk[l]) !== getNormalizedPhoneme(newPhones[k + l])) {
                                match = false;
                                break;
                            }
                        }
                        
                        if (match) {
                            commonChunkFound = true;
                            // The `foundChunkText` should represent the actual phonemes from `newWord` that matched
                            foundChunkText = newPhones.slice(k, k + currentChunk.length).join(' ');
                            break; // Found a match, exit inner loop (looking for chunks in newPhones)
                        }
                    }
                    // --- END NEW LOGIC ---

                    if (commonChunkFound) break; // Found a valid chunk from prevPhones, exit inner loop (iterating prevPhones chunks)
                }
                if (commonChunkFound) break; // Found a valid chunk, exit outer loop (iterating prevPhones start positions)
            }

            if (commonChunkFound) {
                return foundChunkText;
            } else {
                if (!isHintCheck) console.log("No common qualifying chunk found between", prevWord, "and", newWord);
                if (isHintCheck) console.log(`Hint check: No common chunk found for "${newWord}" against "${prevWord}"`); 
                return null;
            }
        }

    // NEW HELPER FUNCTION TO COUNT SHARED PHONEMES
    function countSharedPhonemes(phones1, phones2) {
        if (!phones1 || !phones2) {
            return 0;
        }
        const set1 = new Set(phones1);
        const set2 = new Set(phones2);
        let sharedCount = 0;
        for (const phone of set1) {
            if (set2.has(phone)) {
                sharedCount++;
            }
        }
        return sharedCount;
    }

     // === HANDLE WORD SUBMISSION ===
     async function handleSubmit() {

    // Check if game is in progress
	if (!gameActive) {
	        messageDisplay.textContent = "Game not started. Click 'Start Game' to begin!";
	        return;
	    }
	    if (gamePaused) { // Prevent submission if paused
	        messageDisplay.textContent = "Game is paused. Click 'Resume Game' to continue.";
	        return;
	    }
	    const newWord = wordInput.value.trim().toLowerCase();
	    wordInput.value = '';
	    hintDisplay.textContent = ""; // Clear hint display on new submission

	// Basic validation
	if (!newWord) {
	        messageDisplay.textContent = "Please enter a word.";
	        return;
	    }
	if (usedWords.includes(newWord)) {
	        messageDisplay.textContent = `"${newWord}" already used. Try another.`;
	        return;
	    }
	if (!pronouncing.phonesForWord(newWord)) {
	        messageDisplay.textContent = `"${newWord}" not in dictionary.`;
	        return; // Don't restart timer for invalid words not in dictionary
	    }

	    stopTimer(); // Stop timer as soon as a valid-looking word is submitted

	try {
	// Get phonemes for both words
	// This line might cause an error if currentWordPhonemes wasn't properly initialized in startGame
	        const prevWordPhonemes = pronouncing.phonesForWord(currentWord)[0].map(cleanPhoneme);
	        const newWordPhonemes = pronouncing.phonesForWord(newWord)[0].map(cleanPhoneme);

                   // Check sound transfer
	        const commonChunk = transferSound(currentWord, newWord);
	        if (!commonChunk) {
	            endGame(`Game over! "${newWord}" doesn't share a sound with "${currentWord}".`);
	            return;
	        }

               // Calculate bonuses
	        const newWordSyllables = syllable(newWord);
	        if (newWordSyllables < 2) {
	            endGame(`Game over! "${newWord}" needs â‰¥2 syllables.`);
	            return;
	        }

               // Scoring
	        let baseScore = 10;
	        let timeBonus = (timeLeft >= 20) ? 10 : (timeLeft >= 10) ? 5 : 0;
	        let syllableBonus = (newWordSyllables > 2) ? (newWordSyllables - 2) * 5 : 0;
	        let numberOfSharedPhonemes = countSharedPhonemes(prevWordPhonemes, newWordPhonemes);
	        const SHARED_BONUS_MULTIPLIER = 10;
	        let sharedBonus = numberOfSharedPhonemes * numberOfSharedPhonemes * SHARED_BONUS_MULTIPLIER;

              // Update game state
	        currentScore += baseScore + timeBonus + syllableBonus + sharedBonus;
	        currentStreak++;
	        usedWords.push(newWord);
	        currentWord = newWord;

              // Display feedback
      	  messageDisplay.textContent = `"${newWord}" shares "${commonChunk}"! ` +
                                     `Score: +${baseScore}` +
                                     (timeBonus ? `, Speed: +${timeBonus}` : "") +
                                     (syllableBonus ? `, Syllables: +${syllableBonus}` : "") +
                                     (sharedBonus ? `, Shared Sounds: +${sharedBonus}` : "");

	// Start Level completion check 
                  if (!inForeverMode && currentStreak >= LEVEL_TARGET_WORDS) {
                    displayLevelCompleteScreen(currentLevel, false); // Pass false for inForeverMode
                    return; // Stop handleSubmit, the level complete screen will manage next steps
                }

                // If in forever mode or not enough words for next level, just start next turn
                startTimer(); // This starts the timer for the *next* turn after a successful word (if not a level transition)
             // --- END Level Progression Logic ---

             // These lines only execute if NO level transition occurred (i.e., game continues normally)
	        updateDisplay();
	        updateWordsUsedDisplay();
	        startTimer();

	    } catch (error) { // This is the 'catch' block for the 'try'
	        console.error("Error in handleSubmit:", error);
	        endGame(`An unexpected error occurred: ${error.message}`);
         }
} // This is the end of the handleSubmit function

        // === HINT FUNCTIONALITY ===
        function getHint() {
            const HINT_COST = 100;

            console.log("getHint called. Current score:", currentScore, "Game active:", gameActive, "Current word:", currentWord);
            if (!gameActive) {
                hintDisplay.textContent = "Start a game to get a hint!";
                console.log("Hint not given: Game not active.");
                return;
            }
            if (currentScore < HINT_COST) { 
                hintDisplay.textContent = `Not enough points (need ${HINT_COST}) for a hint.`;
                console.log("Hint not given: Not enough points.");
                return;
            }

            stopTimer(); 
            hintDisplay.textContent = "Finding a hint...";
            hintButton.disabled = true; 

            currentScore -= HINT_COST; 
            updateDisplay();
            messageDisplay.textContent = `${HINT_COST} points deducted for a hint!`;

            let foundHintWord = null;
            const maxHintSearchAttempts = 5000; // Increased for better chance of finding a word
            const dictionaryWords = Object.keys(pronouncing.getDictionary());
            let attempts = 0;

            // Use a small delay to allow UI to update, and prevent freezing
            setTimeout(() => {
                while (attempts < maxHintSearchAttempts && !foundHintWord) {
                    const potentialHintWord = getRandomElement(dictionaryWords);

                    if (usedWords.includes(potentialHintWord)) {
                        attempts++;
                        continue;
                    }

                    const hintWordPhones = pronouncing.phonesForWord(potentialHintWord);
                    if (!hintWordPhones || hintWordPhones.length === 0) {
                        attempts++;
                        continue;
                    }
                    
                    // transferSound handles syllable check internally
                    const commonChunk = transferSound(currentWord, potentialHintWord, true); // true for isHintCheck

                    if (commonChunk) {
                        foundHintWord = potentialHintWord;
                        break; 
                    }
                    attempts++;
                }

                if (foundHintWord) {
                    hintDisplay.textContent = `Hint: Try "${foundHintWord.toUpperCase()}"`;
                    console.log("Hint found:", foundHintWord);
                } else {
                    hintDisplay.textContent = "Could not find an easy hint right now. Keep trying!";
                    console.log(`No hint found after ${attempts} attempts for current word "${currentWord}".`);
                }

                hintButton.disabled = false; 
                startTimer(); 
            }, 50); 
        }


        // === SHARING FUNCTIONS ===

        function getGameURL() {
            return window.location.href.split('?')[0]; 
        }

        function generateShareMessage() {
            const gameURL = getGameURL();
            return `I just scored ${currentScore} points and got a ${currentStreak} streak in Phono! My highest session streak was ${highestSessionStreak}. Can you beat me? Play here: ${gameURL}`; 
        }

        async function copyShareMessage() {
            try {
                const message = generateShareMessage();
                await navigator.clipboard.writeText(message);
                alert("Score message copied to clipboard!");
            } catch (err) {
                console.error('Failed to copy: ', err);
                alert("Failed to copy message. Please copy manually: " + generateShareMessage());
            }
        }

        function shareOnFacebook() {
            const message = generateShareMessage();
            const gameURL = getGameURL();
            const facebookUrl = `https://www.facebook.com/sharer/sharer.php?quote=${encodeURIComponent(message)}&u=${encodeURIComponent(gameURL)}`;
            window.open(facebookUrl, '_blank', 'width=600,height=400');
        }

        function generateChallengeLink() {
            const gameURL = getGameURL();
            const encodedWord = encodeURIComponent(currentWord);
            const challengeUrl = `${gameURL}?challengeWord=${encodedWord}`;
            
            try {
                navigator.clipboard.writeText(challengeUrl);
                alert(`Challenge link copied to clipboard! Share this link to challenge a friend to continue from "${currentWord.toUpperCase()}".`);
            } catch (err) {
                console.error('Failed to copy challenge link: ', err);
                alert("Challenge link: " + challengeUrl + " (Please copy manually)");
            }
        }

        // === EVENT LISTENERS ===
        document.addEventListener('DOMContentLoaded', initGame);

        wordInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                handleSubmit();
            }
        });

        submitButton.addEventListener('click', handleSubmit);

	pauseButton.addEventListener('click', togglePause);

	startGameButton.addEventListener('click', () => {
	if (awaitingNextLevel) {
                    // If we're waiting for the player to continue to the next level
    	            awaitingNextLevel = false; // Reset the flag
	startGameButton.style.display = 'none'; // Hide the "Continue" button
	startGameButton.textContent = "Start New Game"; // Reset button text for future use
	startNextLevel(); // Start the next level
	} else {
                   // Otherwise, it's a regular start game click
	startGame();
            }
        });
        resetGameButton.addEventListener('click', resetGame);

    	// === ACCORDION LOGIC (Should be here once) ===
	    const accordionHeaders = document.querySelectorAll('.accordion-header');
	    accordionHeaders.forEach(header => {
	        header.addEventListener('click', () => {
	            header.classList.toggle('active');
	            const content = header.nextElementSibling;
	      if (content.style.maxHeight) {
	                content.style.maxHeight = null;
	                content.style.padding = '0 15px';
                   } else {
       	         content.style.maxHeight = content.scrollHeight + 'px';
	         content.style.padding = '15px';
            }
        });
    });
	showRulesButton.addEventListener('click', () => {
            // Check if rules section is currently hidden by checking for the 'active-modal' class
            if (!rulesSection.classList.contains('active-modal')) {
                rulesSection.classList.add('active-modal'); // Add class to show as flex
                showRulesButton.textContent = 'Hide Rules';

                // This section resets the accordions to ensure they are closed when the modal opens
                document.querySelectorAll('.accordion-header').forEach(header => {
                    header.classList.remove('active'); // Remove 'active' class from all headers
                    const content = header.nextElementSibling;
                    if (content) {
                        content.style.maxHeight = null; // Collapse content by removing inline max-height
                        content.style.padding = '0 15px'; // Ensure padding is collapsed
                    }
                });

            } else { // If rules section is currently visible
                rulesSection.classList.remove('active-modal'); // Remove class to hide
                showRulesButton.textContent = 'Show Rules';
            }
        });
	// New: Event listener for the close button inside the rules modal
	closeRulesButton.addEventListener('click', () => {
	rulesSection.classList.remove('active-modal'); // Hide the rules overlay
	showRulesButton.textContent = 'Show Rules'; // Reset button text
	});

	// Optional: Close rules if clicked outside the content area (on the overlay itself)
	rulesSection.addEventListener('click', (event) => {
	if (event.target === rulesSection) { // Only if the click is directly on the overlay, not its children
	    rulesSection.classList.remove('active-modal');
	          showRulesButton.textContent = 'Show Rules';
            }
        });

	testSoundButton.addEventListener('click', () => {
  		if (levelCompleteSound) {
		        levelCompleteSound.play().catch(error => {
		            console.error("Error playing test sound:", error);
        		});
    		} else {
        			console.warn("Test sound element not found!");
    		}
	});
        
	copyShareButton.addEventListener('click', copyShareMessage);
        facebookShareButton.addEventListener('click', shareOnFacebook);
        challengeFriendButton.addEventListener('click', generateChallengeLink);
        hintButton.addEventListener('click', getHint); 

// Add this new JavaScript code
document.addEventListener('DOMContentLoaded', () => {
    const accordionHeaders = document.querySelectorAll('.accordion-header');

    accordionHeaders.forEach(header => {
        header.addEventListener('click', () => {
            // Toggle the 'active' class on the clicked header
            header.classList.toggle('active');

            // Get the sibling content div
            const content = header.nextElementSibling;

            // Toggle the display of the content
            if (content.style.maxHeight) {
                // If it has a maxHeight (is open), close it
                content.style.maxHeight = null; // Or '0px'
                content.style.padding = '0 15px'; // Collapse padding
            } else {
                // If it's closed, open it to its scrollHeight
                content.style.maxHeight = content.scrollHeight + 'px';
                content.style.padding = '15px'; // Apply padding when opened
            }

            // Optional: Close other open accordion items (uncomment if desired)
            /*
            accordionHeaders.forEach(otherHeader => {
                if (otherHeader !== header && otherHeader.classList.contains('active')) {
                    otherHeader.classList.remove('active');
                    otherHeader.nextElementSibling.style.maxHeight = null; // Or '0px'
                    otherHeader.nextElementSibling.style.padding = '0 15px';
                }
            });
            */
        });
    });
});
	
    </script>
	<audio id="levelCompleteSound" src="341578__kimp10__success.wav" preload="auto"></audio>
</body>
</html>