<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phono</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400..700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            color: #333;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 100%;
            max-width: 600px;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-family: 'Dancing Script', cursive; /* Applied Dancing Script font */
            font-size: 2.8em;
        }

        #gameTagline {
            font-size: 1.2em; /* Slightly smaller than h1 */
            color: #555; /* Slightly muted color */
            margin-top: -10px; /* Pull it closer to the title */
            margin-bottom: 25px; /* Add some space below it */
            font-style: italic; /* Give it a tagline look */
        }

        .game-controls, .game-info {
            margin-bottom: 20px;
        }

	.mode-selection label {
            margin: 0 10px;
            font-size: 1.1em;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
	    transition: background-color 0.3s ease, box-shadow 0.2s ease;
            outline: none; /* remove default outline, will add custom */        }

	/* Focus styles for accessibility */
	button:focus {
	    outline: 3px solid #ffd700; /* bright yellow outline for strong focus */
	    outline-offset: 3px;
	    box-shadow: 0 0 5px 2px #ffd700;
	}

        button#startGameButton {
            background-color: #28a745;
            color: white;
        }

	button#startGameButton:hover:enabled {
	    background-color: #218838;
	}

        button#startGameButton:hover:enabled {
            background-color: #218838;
        }

        button#resetGameButton {
            background-color: #dc3545;
            color: white;
        }

	button#resetGameButton:hover:enabled {
	    background-color: #c82333;
	}
        
        button#submitButton {
            background-color: #007bff;
            color: white;
        }

        button#submitButton:hover:enabled {
            background-color: #0056b3;
        }

        button#showRulesButton {
            background-color: #6c757d;
            color: white;
        }

        button#showRulesButton:hover {
            background-color: #5a6268;
        }
       
	/* Disabled buttons - slightly muted look */
	button:disabled {
	    opacity: 0.6;
	    cursor: not-allowed;
	    box-shadow: none;
	}

        /* Styles for Share Buttons */
        #shareOptions button {
            background-color: #007bff; /* A default blue */
            color: white;
            margin: 5px;
        }
        #shareOptions button#facebookShareButton { 
            background-color: #1877F2; /* Facebook blue */
        }
        #shareOptions button#facebookShareButton:hover {
            background-color: #166FE5;
        }
        #shareOptions button#copyShareButton {
            background-color: #6c757d; /* Muted color for copy */
        }
        #shareOptions button#copyShareButton:hover {
            background-color: #5a6268;
        }
        #shareOptions button#challengeFriendButton { 
            background-color: #ff9800; /* Orange */
        }
        #shareOptions button#challengeFriendButton:hover {
            background-color: #e68900;
        }

        /* New style for the hint button */
        #hintSection button#hintButton {
            background-color: #ffc107; /* Yellowish/orange */
            color: #333;
            margin-top: 15px; 
            margin-bottom: 5px;
        }

        #hintSection button#hintButton:hover:enabled {
            background-color: #e0a800;
        }

        #hintSection {
            margin-top: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        input[type="text"] {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1.1em;
            width: calc(100% - 130px); /* Adjust width to fit button */
            margin-right: 10px;
            box-sizing: border-box;
        }

        #wordDisplay h2 {
            font-size: 2.5em;
            color: #007bff;
            margin: 20px 0;
            min-height: 1.5em; /* Ensure consistent height */
        }

        .game-info p {
            font-size: 1.2em;
            margin: 5px 0;
        }

        .game-info span {
            font-weight: bold;
            color: #3498db;
        }

        .message {
            margin-top: 20px;
            font-size: 1.1em;
            color: #e74c3c; /* Red for errors/info */
            min-height: 1.2em; /* Ensure consistent height */
        }
        /* Ensure messages have consistent styling, hintDisplay might be separate from messageDisplay */
        #hintDisplay {
            margin-top: 10px;
            font-size: 1.1em;
            min-height: 1.2em;
            color: #007bff; /* Hint text will be blue */
        }

        /* Styles for the new sections */
        #wordsUsedSection, #topScoresSection, #rulesSection, #shareOptions {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
            margin-top: 20px;
            text-align: left;
        }
        
        #rulesSection {
            background-color: #e9f5ff; /* Light blue background */
            border: 1px solid #cceeff; /* Blue border */
        }
        /* Specific styling for share options section */
        #shareOptions {
            background-color: #e0ffe0; /* Light green background */
            border: 1px solid #ccffcc; /* Green border */
            text-align: center;
        }


        #wordsUsedSection h4, #topScoresSection h4, #rulesSection h4, #shareOptions h4 {
            color: #444;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        #wordsUsedList, #topScoresList {
            list-style-type: none; /* Remove default bullet/number */
            padding: 0;
            margin: 0;
            font-size: 0.95em;
            color: #555;
            max-height: 120px; /* Limit height for scrolling */
            overflow-y: auto; /* Enable scrolling */
            border-top: 1px dashed #eee;
            padding-top: 10px;
        }

        #wordsUsedList li, #topScoresList li {
            padding: 4px 0;
            border-bottom: 1px dotted #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #topScoresList {
            list-style-type: decimal; /* Use decimal for numbered list */
            padding-left: 20px; /* Indent for numbers */
            text-align: left; /* Align list items left */
            margin: 0 auto; /* Center the ol itself */
            display: inline-block; /* Allow centering of the ol */
        }

        #topScoresList li:last-child {
            border-bottom: none;
        }

        #rulesSection ol, #rulesSection ul {
            padding-left: 20px;
            margin-bottom: 10px;
        }
        #rulesSection li {
            margin-bottom: 5px;
            line-height: 1.4;
        }

	/* Styles specifically for screens with a maximum width of, say, 600px (typical for phones/small tablets) */
	@media screen and (max-width: 600px) {
	  body {
            font-size: 14px; /* Make text slightly smaller for mobile */
            padding: 10px; /* Reduce overall padding */
    	}

	    .container {
                padding: 15px; /* Override for smaller screens */
                border-radius: 5px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            }

            h1 {
                font-size: 1.8em;
            }

            input[type="text"],
            button {
                width: calc(100% - 10px); /* Make nearly full width (minus margins) */
                margin: 5px 0; /* Stack vertically */
                padding: 15px; /* Larger touch target */
                font-size: 18px; /* Larger text */
            }

            .game-controls {
                flex-direction: column; /* Stack if they were side-by-side */
                align-items: stretch;
            }

            .button-group button {
                margin: 5px 0; /* Stack buttons in a group */
            }
    }
    </style>
</head>
<body>
    <div class="container">
        <h1>Phono</h1> <p id="gameTagline">Outthink. Outlink. Outlast.</p>

        <div class="game-controls">
            <div class="mode-selection">
                <label><input type="radio" name="gameMode" value="basic" checked disabled> Basic (30s)</label>
                <label><input type="radio" name="gameMode" value="advanced" disabled> Advanced (15s)</label>
            </div>

            <button id="startGameButton" disabled aria-label="Start New Game">Start New Game</button>
            <button id="resetGameButton" style="display aria-label="Reset the game": none;" disabled>Reset Game</button>
            <button id="showRulesButton" aria-label="Show the game rules">Show Rules</button>
	    <button id="pauseButton">Pause Game</button>
	    <div id="pausesDisplay">Pauses Left: 2</div>
        </div>

        <div class="game-info">
            <p>Score: <span id="scoreDisplay">0</span></p>
            <p>Streak: <span id="streakDisplay">0</span></p>
            <p>Time Left: <span id="timerDisplay">--</span></p>
            <p>High Score: <span id="highScoreDisplay">0</span></p>
            <p>Highest Streak (Session): <span id="highestSessionStreakDisplay">0</span></p>
        </div>

        <div id="wordDisplay">
            <h2 id="currentWordDisplay"></h2>
        </div>

        <div id="inputSection">
            <input type="text" id="wordInput" placeholder="Enter word here" disabled>
            <button id="submitButton" aria-label="Submit your answer" disabled>Submit Word</button>
        </div>

        <div id="hintSection">
            <button id="hintButton" disabled>Get Hint (Cost: 20 pts)</button>
            <p id="hintDisplay" class="message"></p>
        </div>

        <p id="messageDisplay" class="message"></p>

        <div id="rulesSection" style="display: none;">
            <h4>How to Play Phono:</h4> <ol>
                <li>The game starts with a word.</li>
                <li>Your goal is to type a new word that **shares a common sound chunk** with the previous word.</li>
                <li>**Sound Chunk Rule:** The shared sound chunk must contain at least one vowel phoneme. That means a sound with a vowel and consonant, such as the "AP" sound in "NAPKIN." A consonant alone won't cut it: For example, "BIKER" won't work as the next word after "CATNAP," even though they share the "K" (or hard C) sound.</li> 
		<li>**Syllable Rule:** Your new word must have **at least 2 syllables**.</li>
                <li>**No Repeats:** You cannot use the same word twice in one game.</li>
                <li>You have limited time per turn!</li>
		<li>It takes 10 successful plays to complete Level 1.</li>
            </ol>
            <h4>Scoring:</h4>
            <ul>
                <li>Base points for each correct word.</li>
                <li>**Time Bonus:** Earn extra points for submitting words quickly.</li>
                <li>**Syllable Bonus:** Get bonus points for longer words (more syllables).</li>
                <li>**Sound Chunk bonus:** Get more points for words that share more sound chunks!</li>
                <li>**Hints:** Cost 20 points each.</li>
            </ul>
            <h4>Game Over:</h4>
            <ul>
                <li>If you run out of time.</li>
                <li>If your word does not share a valid sound with the previous word.</li>
                <li>If your word has fewer than 2 syllables.</li>
            </ul>
            <p>Good luck and happy chaining!</p>
        </div>

        <div id="shareOptions" style="display: none;">
            <h4>Share Your Achievement!</h4>
            <button id="copyShareButton">Copy Score Message</button>
            <button id="facebookShareButton">Share on Facebook</button>
            <button id="challengeFriendButton">Challenge a Friend</button>
        </div>

        <div id="wordsUsedSection">
            <h4>Words Used This Round:</h4>
            <ul id="wordsUsedList">
                </ul>
        </div>

        <div id="topScoresSection">
            <h4>Top Scores:</h4>
            <ol id="topScoresList">
                <li>N/A</li> </ol>
        </div>

    </div>

    <script>
        // === PRONOUNCING.JS MODULE (EMBEDDED) ===
        // This IIFE contains the dictionary logic for pronunciation and rhymes.
        window.pronouncing = (function () {
            var dict = {};
            var phones = {};
            var dictionaryLoaded = false; // Flag to track if dictionary is loaded

            var mod = {
                setDictionary: function (text) {
                    text.split('\n').forEach(function (line) {
                        if (!line) return;
                        var parts = line.split(/\s+/);
                        var word = parts[0].toLowerCase();
                        // IMPORTANT FIX: Clean words with (n) suffixes to map to base word
                        word = word.replace(/\(\d+\)$/, ''); // Remove (1), (2) etc. from word suffixes
                        var phone = parts.slice(1);

                        // Ensure dict[word] is an array before pushing
                        if (!Array.isArray(dict[word])) {
                            dict[word] = [];
                        }
                        dict[word].push(phone);

                        phone.forEach(function (p) {
                            if (!phones[p]) {
                                phones[p] = [];
                            }
                            phones[p].push(word);
                        });
                    });
                    console.log("Pronouncing.js dictionary initialized with " + Object.keys(dict).length + " words.");
                    dictionaryLoaded = true; // Set flag after dictionary is loaded
                },

                // Returns all pronunciations (arrays of phonemes) for a given word
                phonesForWord: function (word) {
                    return dict[word.toLowerCase()];
                },

                // Returns a list of words that rhyme with the given word
                // (Note: This function is not used in the final custom rule, but kept for completeness
                // as it's part of the pronouncing.js library)
                rhymes: function (word) {
                    var phones = this.phonesForWord(word);
                    if (!phones) return [];
                    var primaryPhone = phones[0]; // Take the first pronunciation
                    var vowelIndex = -1;
                    for (var i = primaryPhone.length - 1; i >= 0; i--) {
                        if (primaryPhone[i].match(/[AEIOU]/)) { // Simple check for vowel phoneme
                            vowelIndex = i;
                            break;
                        }
                    }
                    if (vowelIndex === -1) return []; // No vowel found, no rhyme

                    var rhymeSound = primaryPhone.slice(vowelIndex).join(' ');
                    var matchingWords = [];
                    for (var p in phones) {
                        if (p.includes(rhymeSound)) {
                            phones[p].forEach(function (w) {
                                if (w !== word) { // Don't include the word itself
                                    matchingWords.push(w);
                                }
                            });
                        }
                    }
                    return matchingWords;
                },

                // New getter to check if the dictionary is loaded
                isDictionaryLoaded: function() {
                    return dictionaryLoaded;
                },

                // New getter to access the dictionary (useful for picking random words)
                getDictionary: function() {
                    return dict;
                }
            };
            return mod;
        })();

        // === GLOBAL GAME STATE VARIABLES ===
        let currentScore = 0;
        let currentStreak = 0;
        let topScores = []; // Array to hold multiple top scores, saved to localStorage
        let highestSessionStreak = 0; // To track highest streak in the current browser session
        let usedWords = []; // To store words already used in the current round
        let gameMode = 'basic'; // Default mode
        let maxTimePerTurn = 30; // Basic mode default
        let timeLeft = maxTimePerTurn;
        let timerInterval = null; // To hold the setInterval ID
        let gameActive = false; // To track if a game is currently running
        let currentWord = ''; // The word currently displayed for the player to respond to
	let gamePaused = false;
	let pausesAvailable = 2; // For example, 2 pauses per game/level
	const PAUSE_COST_PER_USE = 25; // For example, 25 points per pause

        // --- NEW: Level 1 Target Streak ---
        const LEVEL1_TARGET_STREAK = 10;

        // === DOM ELEMENTS ===
        const scoreDisplay = document.getElementById('scoreDisplay');
        const streakDisplay = document.getElementById('streakDisplay');
        const timerDisplay = document.getElementById('timerDisplay');
        const highScoreDisplay = document.getElementById('highScoreDisplay'); // Will show the #1 score from topScores
        const highestSessionStreakDisplay = document.getElementById('highestSessionStreakDisplay');
        const wordsUsedList = document.getElementById('wordsUsedList');     // For used words this round
        const topScoresList = document.getElementById('topScoresList');    // For the persistent top scores list
        const startGameButton = document.getElementById('startGameButton');
        const resetGameButton = document.getElementById('resetGameButton');
        const modeRadios = document.querySelectorAll('input[name="gameMode"]');
        const currentWordDisplay = document.getElementById('currentWordDisplay');
        const wordInput = document.getElementById('wordInput');
        const submitButton = document.getElementById('submitButton');
        const messageDisplay = document.getElementById('messageDisplay');
        const showRulesButton = document.getElementById('showRulesButton');
        const rulesSection = document.getElementById('rulesSection');
        const shareOptions = document.getElementById('shareOptions');
        const copyShareButton = document.getElementById('copyShareButton');
        const facebookShareButton = document.getElementById('facebookShareButton');
        const challengeFriendButton = document.getElementById('challengeFriendButton');
        const hintButton = document.getElementById('hintButton'); 
        const hintDisplay = document.getElementById('hintDisplay'); 
	const pauseButton = document.getElementById('pauseButton');
	const pausesDisplay = document.getElementById('pausesDisplay');


        // === HELPER FUNCTIONS ===

        // Cleans phoneme stress markers (e.g., "AH0" -> "AH", "OW1" -> "OW")
        function cleanPhoneme(phoneme) {
            return phoneme.replace(/[012]/g, '');
        }

        // Determines if a cleaned phoneme (without stress marker) is a vowel sound.
        // Based on CMU Pronouncing Dictionary phoneme set.
        function isVowelPhoneme(phoneme) {
            const cleaned = cleanPhoneme(phoneme);
            // List of CMU vowel phonemes (without stress markers)
            const vowels = new Set(['AA', 'AE', 'AH', 'AO', 'AW', 'AY', 'EH', 'ER', 'EY', 'IH', 'IY', 'OW', 'OY', 'UH', 'UW']);
            return vowels.has(cleaned);
        }

        // Define a mapping for "similar" vowel phonemes for comparison purposes
        // This helps the game recognize intuitive sound connections that CMUdict might differentiate.
        const PHONEME_EQUIVALENCE_GROUP = {
            'AE': 'GROUP_A_LIKE', // as in 'cat'
            'AH': 'GROUP_A_LIKE', // as in 'cup', 'but'
            'AA': 'GROUP_A_LIKE', // as in 'father', 'hot'
            // 'AO': 'GROUP_O_LIKE', // 'all', 'caught' - can be grouped if needed, or kept distinct
            // 'OW': 'GROUP_O_LIKE', // 'go', 'boat'

            // Add other common "fudged" pairs if necessary in future
            // 'EH': 'GROUP_E_LIKE', // 'bed'
            // 'IH': 'GROUP_E_LIKE', // 'bid'
        };

        // Function to get a "normalized" phoneme for comparison, using the equivalence groups
        function getNormalizedPhoneme(phoneme) {
            const cleaned = cleanPhoneme(phoneme);
            return PHONEME_EQUIVALENCE_GROUP[cleaned] || cleaned; // Return grouped value if exists, else cleaned original
        }

        // Basic syllable counting function (can be simple, may not be 100% accurate for all words)
        function syllable(word) {
            const phones = pronouncing.phonesForWord(word);
            if (!phones || phones.length === 0) {
                console.warn(`No phonemes found for syllable count for: ${word}. Returning 0.`);
                return 0;
            }
            let count = 0;
            for (let i = 0; i < phones[0].length; i++) {
                if (isVowelPhoneme(phones[0][i])) {
                    count++;
                }
            }
            return Math.max(1, count);
        }

        // Helper function to get a random element from an array
        function getRandomElement(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }


        // === DICTIONARY LOADING ===
        async function loadPronouncingDictionary() {
            const dictPath = 'cmudict.dict';
            const remoteFallbackURL = 'https://raw.githubusercontent.com/cmusphinx/cmudict/master/cmudict.dict'; 

            let dictionaryText = '';
            messageDisplay.textContent = "Loading dictionary...";

            try {
                console.log("Attempting to load dictionary from relative path:", dictPath);
                const response = await fetch(dictPath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} from ${dictPath}`);
                }
                dictionaryText = await response.text();
                console.log("Loaded dictionary text from relative path.");
            } catch (error) {
                console.warn("Failed to load dictionary from relative path. Falling back to remote URL:", error);
                messageDisplay.textContent = "Failed to load local dictionary, trying remote...";

                try {
                    const response = await fetch(remoteFallbackURL);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} from ${remoteFallbackURL}`);
                    }
                    dictionaryText = await response.text();
                    console.log("Fetched dictionary text from remote URL.");
                } catch (remoteError) {
                    console.error("Failed to load dictionary from any source:", remoteError);
                    messageDisplay.textContent = `Failed to load dictionary: ${remoteError.message}`;
                    throw remoteError;
                }
            }

            if (dictionaryText) {
                pronouncing.setDictionary(dictionaryText);
            } else {
                throw new Error("Dictionary text is empty after loading attempts.");
            }
        }

        // === INITIALIZATION FUNCTION ===
        async function initGame() {
            messageDisplay.textContent = "Loading dictionary...";
            try {
                await loadPronouncingDictionary();
                messageDisplay.textContent = "Dictionary loaded. Ready to play!";
                startGameButton.disabled = false;
                // Only enable 'basic' mode by default, 'advanced' will be unlocked
                modeRadios.forEach(radio => {
                    if (radio.value === 'basic') {
                        radio.disabled = false;
                    } else {
                        radio.disabled = true; // Keep advanced disabled initially
                    }
                });


                const storedTopScores = localStorage.getItem('phonoTopScores'); // Changed key to phonoTopScores
                if (storedTopScores) {
                    topScores = JSON.parse(storedTopScores);
                } else {
                    topScores = [];
                }
                
                updateDisplay();
                updateTopScoresDisplay();

                const urlParams = new URLSearchParams(window.location.search);
                const challengeWord = urlParams.get('challengeWord');
                if (challengeWord && pronouncing.phonesForWord(challengeWord) && syllable(challengeWord) >= 2) {
                    window.history.replaceState({}, document.title, window.location.pathname);
                    startGame(challengeWord);
                    messageDisplay.textContent = `You've been challenged! Continue the chain from "${challengeWord.toUpperCase()}"!`;
                }


            } catch (error) {
                console.error("Game Initialization Error:", error);
                messageDisplay.textContent = `Failed to initialize game: ${error.message}`;
            }
        }


        // === GAME CONTROL FUNCTIONS ===

        function updateDisplay() {
            scoreDisplay.textContent = currentScore;
            streakDisplay.textContent = currentStreak;
            timerDisplay.textContent = timeLeft;
            highScoreDisplay.textContent = topScores.length > 0 ? topScores[0] : 0; 
            highestSessionStreakDisplay.textContent = highestSessionStreak;
	    currentWordDisplay.textContent = currentWord.toUpperCase(); 

        }

        function updateWordsUsedDisplay() {
            wordsUsedList.innerHTML = '';
            if (usedWords.length === 0) {
                return;
            }
            usedWords.forEach(word => {
                const li = document.createElement('li');
                li.textContent = word.toUpperCase();
                wordsUsedList.appendChild(li);
            });
            wordsUsedList.scrollTop = wordsUsedList.scrollHeight;
        }

        function updateTopScoresDisplay() {
            topScoresList.innerHTML = '';
            if (topScores.length === 0) {
                topScoresList.innerHTML = '<li>N/A</li>';
                highScoreDisplay.textContent = 0;
                return;
            }

            highScoreDisplay.textContent = topScores[0]; 

            topScores.forEach((score, index) => {
                const li = document.createElement('li');
                li.textContent = `${score} points`;
                topScoresList.appendChild(li);
            });
        }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);

            timeLeft = maxTimePerTurn;
            updateDisplay();

            timerInterval = setInterval(() => {
                timeLeft--;
                updateDisplay();

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                    endGame("Time's up! Game over. Your streak ended.");
                }
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

function togglePause() {
    if (!gameActive) { // Cannot pause if game isn't even active
        messageDisplay.textContent = "Game not started. Click 'Start Game' to begin!";
        return;
    }

    if (!gamePaused) { // If game is currently running, pause it
        if (pausesAvailable <= 0) {
            messageDisplay.textContent = "No pauses left!";
            return;
        }

        // Deduct points
        currentScore = Math.max(0, currentScore - PAUSE_COST_PER_USE); // Ensure score doesn't go below 0
        pausesAvailable--; // Decrease available pauses

        // Update state
        gamePaused = true;
        clearInterval(timerInterval); // Stop the timer

        // Update UI
        wordInput.disabled = true; // Disable input while paused
        submitButton.disabled = true; // Disable submit button
        pauseButton.textContent = "Resume Game";
        messageDisplay.textContent = `Game Paused! -${PAUSE_COST_PER_USE} points. Click to resume.`;
        updateDisplay(); // Update score and other displays

    } else { // If game is currently paused, resume it
        // Update state
        gamePaused = false;
        startTimer(); // Resume the timer from where it left off

        // Update UI
        wordInput.disabled = false; // Enable input
        submitButton.disabled = false; // Enable submit button
        pauseButton.textContent = "Pause Game";
        messageDisplay.textContent = ""; // Clear pause message (or revert to previous if desired)
    }
    updatePausesDisplay(); // Update the display for pauses left
}

function updatePausesDisplay() {
    if (pausesDisplay) { // Check if the display element exists
        pausesDisplay.textContent = `Pauses Left: ${pausesAvailable}`;
    }
}
        function endGame(message) {
            gameActive = false;
            stopTimer();
            wordInput.disabled = true;
            submitButton.disabled = true;
            hintButton.disabled = true; 
            hintDisplay.textContent = ""; 
            resetGameButton.disabled = true; // Ensure disabled at game end
            currentWordDisplay.textContent = "GAME OVER!";
            
            if (currentStreak > highestSessionStreak) {
                highestSessionStreak = currentStreak;
            }

            if (currentScore > 0) {
                topScores.push(currentScore);
                topScores.sort((a, b) => b - a);
                topScores = topScores.slice(0, 5);
                localStorage.setItem('phonoTopScores', JSON.stringify(topScores)); 
            }

            scoreDisplay.textContent = currentScore;
            streakDisplay.textContent = currentStreak;
            messageDisplay.textContent = message;
            if (currentScore > 0 && topScores.length > 0 && currentScore === topScores[0]) {
                 messageDisplay.textContent += ` NEW OVERALL HIGH SCORE: ${topScores[0]}!`;
            }

            updateDisplay();
            updateTopScoresDisplay();

            startGameButton.style.display = 'inline-block';
            resetGameButton.style.display = 'none'; 
            // Re-enable only 'basic' mode for next game, advanced stays disabled unless unlocked
            modeRadios.forEach(radio => {
                if (radio.value === 'basic') {
                    radio.disabled = false;
                } else if (radio.value === 'advanced') {
                    // Only disable advanced if it was unlocked in a previous basic game
                    // This retains its unlocked status for future games
                    // But for starting a new game, it should be disabled if not previously unlocked.
                    // This logic is tricky. Let's simplify:
                    // If Level 1 was completed, leave Advanced enabled. Otherwise, disable.
                    // The simplest is to always reset advanced to disabled.
                    // If a player wants to select it, they should have completed Level 1 already.
                    radio.disabled = true; 
                }
            });


            shareOptions.style.display = 'block';
        }

        function resetGame() {
            stopTimer();
            currentScore = 0;
            currentStreak = 0;
            timeLeft = maxTimePerTurn;
            gameActive = false;
            usedWords = [];
            updateWordsUsedDisplay();
            updateDisplay();
            updateTopScoresDisplay();
            messageDisplay.textContent = "Click 'Start New Game' to begin!";
            currentWordDisplay.textContent = "";
            wordInput.value = '';
            wordInput.disabled = true;
            submitButton.disabled = true;
            hintButton.disabled = true; 
            hintDisplay.textContent = ""; 
            resetGameButton.disabled = true; // Ensure disabled after reset

            startGameButton.style.display = 'inline-block';
            resetGameButton.style.display = 'none'; 
            // Reset mode radios state: only basic enabled
            modeRadios.forEach(radio => {
                if (radio.value === 'basic') {
                    radio.disabled = false;
                } else {
                    radio.disabled = true; 
                }
            });

            shareOptions.style.display = 'none';
        }

        function setGameMode(mode) {
            gameMode = mode;
            if (gameMode === 'basic') {
                maxTimePerTurn = 30;
            } else { // 'advanced' mode
                maxTimePerTurn = 15;
            }
            timeLeft = maxTimePerTurn;
            updateDisplay();
            console.log(`Game mode set to ${gameMode}, time per turn: ${maxTimePerTurn}s`);
        }

        function startGame(startWord = null) {
            if (!pronouncing.isDictionaryLoaded()) {
                 messageDisplay.textContent = "Dictionary not loaded yet. Please wait.";
                 return;
            }

            resetGame(); // Reset any existing game state
            gameActive = true;
	    pausesAvailable = 2; // Reset pauses on full game reset
	    gamePaused = false; // Ensure game is not paused
	    updatePausesDisplay();
	    wordInput.disabled = false; // Ensure input is enabled
	    submitButton.disabled = false; // Ensure submit button is enabled
	    pauseButton.textContent = "Pause Game"; // Ensure button text is correct  // ...
	    timeLeft = maxTimePerTurn; // Or your initial time setting
	    updateDisplay(); // To show reset timer, score, etc.

            // Disable all mode radios once game starts
            modeRadios.forEach(radio => radio.disabled = true);
            startGameButton.style.display = 'none';
            resetGameButton.style.display = 'inline-block';
            resetGameButton.disabled = false; // Enable the Reset Game button

            wordInput.disabled = false;
            submitButton.disabled = false;
            hintButton.disabled = false; 
            hintDisplay.textContent = ""; 
            wordInput.focus();

            if (startWord && pronouncing.phonesForWord(startWord) && syllable(startWord) >= 2) {
                currentWord = startWord;
            } else {
                const dictionaryWords = Object.keys(pronouncing.getDictionary());
                if (dictionaryWords.length === 0) {
                    messageDisplay.textContent = "Error: Dictionary is empty or failed to load.";
                    endGame("Failed to find starting word.");
                    return;
                }

                let foundStartWord = false;
                let attempts = 0;
                const maxAttempts = 100; 

                while (!foundStartWord && attempts < maxAttempts) {
                    const potentialWord = dictionaryWords[Math.floor(Math.random() * dictionaryWords.length)];
                    try {
                        if (syllable(potentialWord) >= 2) {
                            currentWord = potentialWord;
                            foundStartWord = true;
                        }
                    } catch (e) {
                        console.error("Error checking syllables for potential start word:", potentialWord, e);
                    }
                    attempts++;
                }

                if (!foundStartWord) {
                    messageDisplay.textContent = "Could not find a suitable random starting word (at least 2 syllables). Try reloading.";
                    endGame("Failed to find starting word.");
                    return;
                }
            }

            usedWords.push(currentWord);
            updateWordsUsedDisplay();
            currentWordDisplay.textContent = currentWord.toUpperCase();
            messageDisplay.textContent = "";
            startTimer();
        }

        // === MAIN GAME LOGIC (transferSound) ===
        // isHintCheck: Set to true if this call is for a hint, to suppress console logs
        function transferSound(prevWord, newWord, isHintCheck = false) { 
            if (!isHintCheck) { // Only log if it's not a hint check
                console.log(`--- Custom Phono Rule: prevWord=${prevWord}, newWord=${newWord} ---`);
            }

            const prevPhonesArr = pronouncing.phonesForWord(prevWord);
            const newPhonesArr = pronouncing.phonesForWord(newWord);

            if (!prevPhonesArr || prevPhonesArr.length === 0) {
                if (!isHintCheck) console.warn(`No phonemes found for previous word: ${prevWord}`);
                return null;
            }
            if (!newPhonesArr || newPhonesArr.length === 0) {
                if (!isHintCheck) console.warn(`No phonemes found for new word: ${newWord}`);
                return null;
            }

            const prevPhones = prevPhonesArr[0].map(cleanPhoneme);
            const newPhones = newPhonesArr[0].map(cleanPhoneme);

            if (!isHintCheck) {
                console.log(`Cleaned Prev Phones (${prevWord}):`, prevPhones);
                console.log(`Cleaned New Phones (${newWord}):`, newPhones);
            }

            let newWordSyllables;
            try {
                newWordSyllables = syllable(newWord);
                if (!isHintCheck) console.log(`Syllables for new word "${newWord}": ${newWordSyllables}`);
                if (newWordSyllables < 2) {
                    if (!isHintCheck) {
                        console.log(`Rule 3 failed: "${newWord}" has ${newWordSyllables} syllables, requires 2 or more.`);
                        messageDisplay.textContent = `"${newWord}" must have at least 2 syllables.`;
                    }
                    return null;
                }
            } catch (e) {
                if (!isHintCheck) {
                    console.error("Error calculating syllables for new word:", e);
                    messageDisplay.textContent = `Error checking syllables for "${newWord}".`;
                }
                return null;
            }

            let commonChunkFound = false;
            let foundChunkText = '';

            // Iterate through all possible chunks from prevPhones
            for (let i = 0; i < prevPhones.length; i++) {
                for (let j = i; j < prevPhones.length; j++) {
                    const currentChunk = prevPhones.slice(i, j + 1);

                    if (currentChunk.length === 0) continue;

                    // Ensure the current chunk (from prevWord) contains at least one vowel
                    const containsVowel = currentChunk.some(p => isVowelPhoneme(p));
                    if (!containsVowel) {
                        continue;
                    }

                    // --- NEW LOGIC FOR FLEXIBLE MATCH ---
                    // Try to find this currentChunk (flexibly) within newPhones
                    
                    // Iterate through newPhones to find a sequence that flexibly matches currentChunk
                    for (let k = 0; k <= newPhones.length - currentChunk.length; k++) {
                        let match = true;
                        // Compare the normalized versions of phonemes
                        for (let l = 0; l < currentChunk.length; l++) {
                            // If normalized phonemes don't match, this chunk is not a flexible match
                            if (getNormalizedPhoneme(currentChunk[l]) !== getNormalizedPhoneme(newPhones[k + l])) {
                                match = false;
                                break;
                            }
                        }
                        
                        if (match) {
                            commonChunkFound = true;
                            // The `foundChunkText` should represent the actual phonemes from `newWord` that matched
                            foundChunkText = newPhones.slice(k, k + currentChunk.length).join(' ');
                            break; // Found a match, exit inner loop (looking for chunks in newPhones)
                        }
                    }
                    // --- END NEW LOGIC ---

                    if (commonChunkFound) break; // Found a valid chunk from prevPhones, exit inner loop (iterating prevPhones chunks)
                }
                if (commonChunkFound) break; // Found a valid chunk, exit outer loop (iterating prevPhones start positions)
            }

            if (commonChunkFound) {
                return foundChunkText;
            } else {
                if (!isHintCheck) console.log("No common qualifying chunk found between", prevWord, "and", newWord);
                if (isHintCheck) console.log(`Hint check: No common chunk found for "${newWord}" against "${prevWord}"`); 
                return null;
            }
        }

    // NEW HELPER FUNCTION TO COUNT SHARED PHONEMES
    function countSharedPhonemes(phones1, phones2) {
        if (!phones1 || !phones2) {
            return 0;
        }
        const set1 = new Set(phones1);
        const set2 = new Set(phones2);
        let sharedCount = 0;
        for (const phone of set1) {
            if (set2.has(phone)) {
                sharedCount++;
            }
        }
        return sharedCount;
    }

        // === HANDLE WORD SUBMISSION ===
        async function handleSubmit() {
 	// Check if game is in progress
        if (!gameActive) {
            messageDisplay.textContent = "Game not started. Click 'Start Game' to begin!";
            return;
	}
	if (gamePaused) { // Prevent submission if paused
        messageDisplay.textContent = "Game is paused. Click 'Resume Game' to continue.";
        return;
	}
            const newWord = wordInput.value.trim().toLowerCase();
            wordInput.value = '';
            hintDisplay.textContent = ""; // Clear hint display on new submission

	// Basic validation
            if (!newWord) {
                messageDisplay.textContent = "Please enter a word.";
                startTimer();
                return;
            }
            if (usedWords.includes(newWord)) {
                messageDisplay.textContent = `"${newWord}" already used. Try another.`;
                startTimer();
                return;
            }
            if (!pronouncing.phonesForWord(newWord)) {
                messageDisplay.textContent = `"${newWord}" not in dictionary.`;
                return;
            }

            stopTimer();

            try {
                // Get phonemes for both words
                const prevWordPhonemes = pronouncing.phonesForWord(currentWord)[0].map(cleanPhoneme);
                const newWordPhonemes = pronouncing.phonesForWord(newWord)[0].map(cleanPhoneme);

                // Check sound transfer
                const commonChunk = transferSound(currentWord, newWord);
                if (!commonChunk) {
                    endGame(`Game over! "${newWord}" doesn't share a sound with "${currentWord}".`);
                    return;
                }

                // Calculate bonuses
                const newWordSyllables = syllable(newWord);
                if (newWordSyllables < 2) {
                    endGame(`Game over! "${newWord}" needs ≥2 syllables.`);
                    return;
                }

		// Scoring
                let baseScore = 10;
                let timeBonus = (timeLeft >= 20) ? 10 : (timeLeft >= 10) ? 5 : 0;
                let syllableBonus = (newWordSyllables > 2) ? (newWordSyllables - 2) * 5 : 0;
		let numberOfSharedPhonemes = countSharedPhonemes(prevWordPhonemes, newWordPhonemes);
		// A multiplier of 10 means: 1 shared = 10 pts, 2 shared = 40 pts, 3 shared = 90 pts
		const SHARED_BONUS_MULTIPLIER = 10; 
		let sharedBonus = numberOfSharedPhonemes * numberOfSharedPhonemes * SHARED_BONUS_MULTIPLIER;                

		// Update game state
                currentScore += baseScore + timeBonus + syllableBonus + sharedBonus;
                currentStreak++;
                usedWords.push(newWord);
                currentWord = newWord;

                // Display feedback
                messageDisplay.textContent = `"${newWord}" shares "${commonChunk}"! ` +
                                           `Score: +${baseScore}` +
                                           (timeBonus ? `, Speed: +${timeBonus}` : "") +
                                           (syllableBonus ? `, Syllables: +${syllableBonus}` : "") +
                                           (sharedBonus ? `, Shared Sounds: +${sharedBonus}` : "");

                // Level completion check
		 if (gameMode === 'basic' && currentStreak === LEVEL1_TARGET_STREAK) {
		        messageDisplay.textContent += " 🎉 LEVEL 1 COMPLETE! 🎉 You've achieved a streak of 10. You can now try Level 2 (Advanced Mode)!";
		        modeRadios.forEach(radio => {
		if (radio.value === 'advanced') {
		                radio.disabled = false;
		            }
		 });
	        }

		    updateDisplay();
		    updateWordsUsedDisplay();
		    startTimer();

		} catch (error) {
		console.error("Error in handleSubmit:", error); // Added console.error for better debugging
		        // If an error occurs in the try block (e.g., dictionary lookup fails),
		        // you might want to end the game or show a specific error message.
	        endGame(`An unexpected error occurred: ${error.message}`);
	    }
      } // End of handleSubmit function

        // === HINT FUNCTIONALITY ===
        function getHint() {
            const HINT_COST = 20;

            console.log("getHint called. Current score:", currentScore, "Game active:", gameActive, "Current word:", currentWord);
            if (!gameActive) {
                hintDisplay.textContent = "Start a game to get a hint!";
                console.log("Hint not given: Game not active.");
                return;
            }
            if (currentScore < HINT_COST) { 
                hintDisplay.textContent = `Not enough points (need ${HINT_COST}) for a hint.`;
                console.log("Hint not given: Not enough points.");
                return;
            }

            stopTimer(); 
            hintDisplay.textContent = "Finding a hint...";
            hintButton.disabled = true; 

            currentScore -= HINT_COST; 
            updateDisplay();
            messageDisplay.textContent = `${HINT_COST} points deducted for a hint!`;

            let foundHintWord = null;
            const maxHintSearchAttempts = 5000; // Increased for better chance of finding a word
            const dictionaryWords = Object.keys(pronouncing.getDictionary());
            let attempts = 0;

            // Use a small delay to allow UI to update, and prevent freezing
            setTimeout(() => {
                while (attempts < maxHintSearchAttempts && !foundHintWord) {
                    const potentialHintWord = getRandomElement(dictionaryWords);

                    if (usedWords.includes(potentialHintWord)) {
                        attempts++;
                        continue;
                    }

                    const hintWordPhones = pronouncing.phonesForWord(potentialHintWord);
                    if (!hintWordPhones || hintWordPhones.length === 0) {
                        attempts++;
                        continue;
                    }
                    
                    // transferSound handles syllable check internally
                    const commonChunk = transferSound(currentWord, potentialHintWord, true); // true for isHintCheck

                    if (commonChunk) {
                        foundHintWord = potentialHintWord;
                        break; 
                    }
                    attempts++;
                }

                if (foundHintWord) {
                    hintDisplay.textContent = `Hint: Try "${foundHintWord.toUpperCase()}"`;
                    console.log("Hint found:", foundHintWord);
                } else {
                    hintDisplay.textContent = "Could not find an easy hint right now. Keep trying!";
                    console.log(`No hint found after ${attempts} attempts for current word "${currentWord}".`);
                }

                hintButton.disabled = false; 
                startTimer(); 
            }, 50); 
        }


        // === SHARING FUNCTIONS ===

        function getGameURL() {
            return window.location.href.split('?')[0]; 
        }

        function generateShareMessage() {
            const gameURL = getGameURL();
            return `I just scored ${currentScore} points and got a ${currentStreak} streak in Phono! My highest session streak was ${highestSessionStreak}. Can you beat me? Play here: ${gameURL}`; 
        }

        async function copyShareMessage() {
            try {
                const message = generateShareMessage();
                await navigator.clipboard.writeText(message);
                alert("Score message copied to clipboard!");
            } catch (err) {
                console.error('Failed to copy: ', err);
                alert("Failed to copy message. Please copy manually: " + generateShareMessage());
            }
        }

        function shareOnFacebook() {
            const message = generateShareMessage();
            const gameURL = getGameURL();
            const facebookUrl = `https://www.facebook.com/sharer/sharer.php?quote=${encodeURIComponent(message)}&u=${encodeURIComponent(gameURL)}`;
            window.open(facebookUrl, '_blank', 'width=600,height=400');
        }

        function generateChallengeLink() {
            const gameURL = getGameURL();
            const encodedWord = encodeURIComponent(currentWord);
            const challengeUrl = `${gameURL}?challengeWord=${encodedWord}`;
            
            try {
                navigator.clipboard.writeText(challengeUrl);
                alert(`Challenge link copied to clipboard! Share this link to challenge a friend to continue from "${currentWord.toUpperCase()}".`);
            } catch (err) {
                console.error('Failed to copy challenge link: ', err);
                alert("Challenge link: " + challengeUrl + " (Please copy manually)");
            }
        }

        // === EVENT LISTENERS ===
        document.addEventListener('DOMContentLoaded', initGame);

        wordInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                handleSubmit();
            }
        });

        submitButton.addEventListener('click', handleSubmit);

	pauseButton.addEventListener('click', togglePause);

        modeRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                setGameMode(event.target.value);
            });
        });

        startGameButton.addEventListener('click', () => startGame());

        resetGameButton.addEventListener('click', resetGame);

        showRulesButton.addEventListener('click', () => {
            if (rulesSection.style.display === 'none') {
                rulesSection.style.display = 'block';
                showRulesButton.textContent = 'Hide Rules';
            } else {
                rulesSection.style.display = 'none';
                showRulesButton.textContent = 'Show Rules';
            }
        });

        copyShareButton.addEventListener('click', copyShareMessage);
        facebookShareButton.addEventListener('click', shareOnFacebook);
        challengeFriendButton.addEventListener('click', generateChallengeLink);
        hintButton.addEventListener('click', getHint); 
    </script>
</body>
</html>